/*******************************************************************************
Copyright 2016 Microchip Technology Inc. (www.microchip.com)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

To request to license the code under the MLA license (www.microchip.com/mla_license), 
please contact mla_licensing@microchip.com
*******************************************************************************/


/********************************************************************
To use this demo, program a device with the firmware from this project.
Then plug the device into a Windows 7 or Windows Vista SP1+ based PC.

MSDN documentation for the "WM_GESTURE" messages indicate that they are
currently only supported in Windows 7.  WM_GESTURE messages can be used
by PC applications to receive information related to a user's input.  
However, Windows Vista SP1 still has some digitizer input 
capabilities, and can therefore still be used to experiment with this demo.
The demo experience will be superior under Windows 7 however, as not
all touch related capabilities and features are enabled in Windows Vista.

The device should enumerate as a HID class multi-touch capable
digitizer device.  Windows 7 and Windows Vista features associated 
with "Windows Touch" should automatically become activated.  
Under default versions of Windows XP, the device should still enumerate 
as a HID class device, but no new digitizer input functionality will 
be activated.

Digitizer tablets send absolute contact position information
to the host.  This is a bit different compared to conventional mouse
devices, in that mice send relative X/Y direction movement information,
instead of an absolute location.

Since the demo boards that this firmware is intended to be run on
do not include an actual multi-touch tablet area, the firmware simply
emulates the tablet by sending the same data (and formatting) that a tablet
would actually be used to produce.  The demo board pushbutton "sw3"
(see definition in the HardwareProfile - (board name).h file)
can be used to make the demo board send simulated gesture info to the host.

To use this demo, open up an Internet Explorer window, and go to some website 
(ex: www.microchip.com/usb).
The web page opened should be large enough that both vertical and 
horizontal scrollbars will become active when zoomed in. Click on some 
link, and then click the back button.  The purpose of this is to enable both 
the forward and back buttons in the web broswer.  
This demo will send gesture information to the OS that can be interpreted as 
forward and back "flick" gestures, which can be used to control the web browser.

Now try pressing the pushbutton on the demo board repeatedly.  Each press
of the pushbutton should send a bunch of IN packets to the host, which contain
the information that would typically be generated by a human user interacting 
with a multi-touch capable digitizer screen.

The firmware will send traffic to emulate both single touch and multi-touch 
(up to 2 simultaneous contacts) gestures, based on the number of times the
pushbutton has been pressed.  Under Windows 7 (Vista will be somewhat different),
the following gestures will be sent and should be recognized by Internet Explorer:

1.  Emulate a single touch "back" gesture operation.  
		This is done by pressing only one finger down, and by moving it right quickly (X plus)
2.  Emulate a single touch "forward" gesture operation.  
		This is done by pressing only one finger down, and by moving it left quickly (X minus)
3.  Emulate a multi-touch zoom-in operation ("un-pinch" index and thumb fingers)
4.  Emulate a multi-touch zoom-in operation ("un-pinch" index and thumb fingers)
5.  Emulate a multi-touch zoom-in operation ("un-pinch" index and thumb fingers)
6.  Emulate a multi-touch horizontal scroll right operation 
      This is done by using two fingers simultaneously and moving them both to the left (X minus)
7.  Emulate a multi-touch horizontal scroll left operation
      This is done by using two fingers simultaneously and moving them both to the right (X plus)
8.  Emulate a single touch scroll down operation.  
      This is done by pressing only one finger down, and by moving it down (Y plus)
9.  Emulate a single touch scroll up operation.  
      This is done by pressing only one finger down, and by moving it up (Y minus)
10. Emulate a multi-touch zoom-out operation (pinch two fingers together)

11+. Upon pressing the button 11 times, the firmware will go back to state 1. Subsequent 
       presses of the button will step through and repeat the above gestures 1-10.

Note: The above demo zooms in three times in a row (presses 3-5).  The purpose of this
is to zoom in sufficiently so that the horizontal and vertical scoll bars will become
active.  The gestures associated with button presses 6-9 perform scroll operations,
but only if the scroll bars are active.

Note2: This demo was tested and developed primarily on 64-bit Windows 7 beta build 7000, 
with some additional testing on Windows Vista SP1.  At the time of this development,
Windows 7 is not yet a finalized and released product.  If you have trouble getting
this demo to work correctly, check to see if there is a later version of this demo
available from the Microchip USB design center: www.microchip.com/usb

Additionally, try adjusting some of the user adjustable controls for 
Pen and Touch Input Devices.  These adjustments can be found from the control panel 
within Windows.


This demo is configured by default to support up to two simultaneous contacts,
by using "parallel reporting" (all data for each contact is contained in each
HID report packet sent to the host).  The demo can be modified to support additional
contacts if the report descriptor in usb_config.h is modified, and the appropriate
contact data is sent to the host for each HID report.
********************************************************************/


/** INCLUDES *******************************************************/
#include <stdint.h>
#include <stdbool.h>

#include "system.h"

#include "usb.h"
#include "usb_device_hid.h"

/** VARIABLES ******************************************************/
/* Some processors have a limited range of RAM addresses where the USB module
 * is able to access.  The following section is for those devices.  This section
 * assigns the buffers that need to be used by the USB module into those
 * specific areas.
 */
#if defined(FIXED_ADDRESS_MEMORY)
    #if defined(COMPILER_MPLAB_C18)
        #pragma udata DEVICE_HID_DIGITIZER_IN_BUFFER=DEVICE_HID_DIGITIZER_IN_BUFFER_ADDRESS
            static unsigned char hid_report_in[HID_INT_IN_EP_SIZE];
        #pragma udata
    #elif defined(__XC8)
        static unsigned char hid_report_in[HID_INT_IN_EP_SIZE] DEVICE_HID_DIGITIZER_IN_BUFFER_ADDRESS;
    #endif
#else
    static unsigned char hid_report_in[HID_INT_IN_EP_SIZE];
#endif
    
static uint16_t DebounceCounter;
static bool SwitchDebouncing;
static uint8_t TimesPressed;		//Keeps track of how many times the button was pressed, to decide what to do next
static bool FlickPending;		//TRUE if we are busy sending a flick, FALSE if no data is being sent right now
static uint8_t ReportsSent;
static bool CoordinatesChanging;
static uint16_t XCoordinate;
static uint16_t YCoordinate;
static uint16_t SOFCount;			//Can get updated in interrupt context if using USB interrupts instead of polling
static uint16_t SOFCountIntSafe;	//Shadow holding variable for the SOFCounter.  This number will not get updated in the interrupt context.
static uint16_t SOFCountIntSafeOld;
static USB_HANDLE lastTransmission;
static unsigned char buffer[HID_INT_IN_EP_SIZE];


/** DEFINITIONS ****************************************************/
#define X_COORD_HOME	(uint16_t)0x2800
#define Y_COORD_HOME	(uint16_t)0x4000

#define DEBOUNCE_COUNT                  50

/** Private Prototypes *********************************************/
static void Emulate_Digitizer(void);
static void DebounceSwitch(void);

/*********************************************************************
* Function: void APP_DeviceHIDDigitizerInitialize(void);
*
* Overview: Initializes the demo code
*
* PreCondition: None
*
* Input: None
*
* Output: None
*
********************************************************************/
void APP_DeviceHIDDigitizerInitialize()
{
    //enable the HID endpoint
    USBEnableEndpoint(HID_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);

    //Used for sw3 pushbutton debouncing
    TimesPressed = 0;			//Tracks number of times the pushbutton is pressed
    DebounceCounter = 0;		//Used for pushbutton debounce
    SwitchDebouncing = false;

    //Initialize digitizer emulation variables.
    XCoordinate = X_COORD_HOME;
    YCoordinate = Y_COORD_HOME;
    FlickPending = false; 	//Not currently sending a gesture
    ReportsSent = 0;

    //initialize the variable holding the handle for the last
    // transmission
    lastTransmission = 0;
}

/*********************************************************************
* Function: void APP_DeviceHIDDigitizerInitialize(void);
*
* Overview: Initializes the demo code
*
* PreCondition: None
*
* Input: None
*
* Output: None
*
********************************************************************/
void APP_DeviceHIDDigitizerSOFHandler()
{
    // No need to clear UIRbits.SOFIF to 0 here.
    // Callback caller is already doing that.

    //Using SOF packets (which arrive at 1ms intervals) for time
    //keeping purposes in this demo.  This enables this demo to send constant
    //velocity contact point X/Y coordinate movement.
    SOFCount++;
    
    DebounceSwitch();
}


/*********************************************************************
* Function: void APP_DeviceHIDDigitizerTasks(void);
*
* Overview: Keeps the Custom HID demo running.
*
* PreCondition: The demo should have been initialized and started via
*   the APP_DeviceHIDDigitizerInitialize() and APP_DeviceHIDDigitizerStart() demos
*   respectively.
*
* Input: None
*
* Output: None
*
********************************************************************/
void APP_DeviceHIDDigitizerTasks()
{
    /* If the device is not configured yet, or if the device is suspended
     * then exit this function immediately since we can't actually send any
     * application data.
     */
    if( (USBGetDeviceState() < CONFIGURED_STATE) || 
        (USBIsDeviceSuspended() == true) )
    {
        return;
    }
    
    //Need to be careful when reading the SOFCounter variable.  If USB interrupts are enabled,
    //the SOFCounter can potentially get updated while you are still reading from it.
    USBMaskInterrupts();
    SOFCountIntSafe = SOFCount;
    USBUnmaskInterrupts();
    
    //We use the SOFCounterIntSafe variable as a form of clock.  Microsoft's
    //Windows Touch related docoumentation implies that Windows can use
    //"additional heuristics" in determining if data sent from a touch device
    //is valid or not.  If for instance the reported contact point suddenly
    //jumps a great distance (apparent velocity greatly exceeding anything that
    //a real human contact would produce), the operating system may conceivably
    //choose to discard the evidently impossible data.

    //Therefore, it is important that data sent to the host be "realistic"
    //to ensure that it gets processed correctly.  In order to make this
    //easier to accomplish in this demo, we use the SOF packets (sent once every 1ms
    //on a full speed USB bus) as a timer, so that we can use it to vary our reported
    //contact point X and Y coordinates in a smooth real time "believable" (constant
    //velocity) manner. In a real application with a real digitizer touch pad, it
    //may not necessarily be required to independently keep track of "time",
    //since presumably the input data is being generated in a realisitic real-time
    //fashion by the human interacting with it.  Specific requirements will however
    //vary based on the type of touch contact point sensing technology employed
    //(ex: optical, capacitive, magnetic, etc.).

    //Check if the pushbutton is currently pressed.
    //If the user presses the button, send a flurry of packets emulating a touch gesture
        if((BUTTON_IsPressed(BUTTON_DEVICE_HID_DIGITIZER_DEMO) == true) && (SwitchDebouncing == false))
    {
        SwitchDebouncing = true;
        FlickPending = true;
        ReportsSent = 0;

        USBMaskInterrupts();
        SOFCount = 0;
        USBUnmaskInterrupts();

        SOFCountIntSafe = 0;
        SOFCountIntSafeOld = 0;
        CoordinatesChanging = true;
        XCoordinate = X_COORD_HOME;
        YCoordinate = Y_COORD_HOME;
        TimesPressed++;
        if(TimesPressed >= 6)
        {
            //Restart state machine, but don't need to go back to press 1,
            //which just sets cursor to home x-y coords
            TimesPressed = 2;
        }
    }

    //Send data for a gesture if needed
    if(FlickPending == true)
    {
        Emulate_Digitizer();
    }
}

/******************************************************************************
 * Function:        void DebounceSwitch(void)
 *
 * PreCondition:    Switch sw3 should be already initialized.
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:
 *
 * Overview:    This is a non-blocking function that checks the sw3 pin
 *              state.  It uses a counter to make sure the user is no longer
 *              pressing the button, and the value has been steady for a long
 *              time before it "re-enables" the button so that it may
 *              register the next user press action.
 *
 * Note:
 *****************************************************************************/
static void DebounceSwitch(void)
{
    //Perform non-blocking switch debounce operation.
    //User must remove finger from button for awhile before the button becomes
    //active again.
    if(BUTTON_IsPressed(BUTTON_DEVICE_HID_DIGITIZER_DEMO) == true)
    {
        //Immediately reset the counter if the pin is (still) low.
        DebounceCounter = 0;
    }
    else if((BUTTON_IsPressed(BUTTON_DEVICE_HID_DIGITIZER_DEMO) == false) && (SwitchDebouncing == true))
    {
        //Keep track of how long it has been continuously pressed without interruption.
        DebounceCounter++;
    }
    
    if((SwitchDebouncing == true) && (DebounceCounter == DEBOUNCE_COUNT))
    {
        //Button was continuously released long enough that it must be done bouncing
        DebounceCounter = 0;
        SwitchDebouncing = false;
    }
}


/******************************************************************************
 * Function:        void Emulate_Digitizer(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    The ownership of the USB buffers will change according
 *                  to the required operation
 *
 * Overview:        This routine will emulate the function of the pen digitizer.  It
 *					does this by sending IN packets of data to the host
 *					
 *					The generic function HIDTxPacket() is used to send HID
 *					IN packets over USB to the host.
 *
 * Note:            
 *
 *****************************************************************************/
static void Emulate_Digitizer(void)
{   
    //Make sure to verify that the endpoint is not busy, before writing to
    //the endpoint buffer and calling HIDTxPacket().
    if(HIDTxHandleBusy(lastTransmission) == 0)
    {
        //Find the delta in ms, but multiply by 32 to get more X/Y coordinate movement.
        //We will use the SOF (1/ms) time base to change our X/Y coordinates
        //for constant velocity movement.
        uint16_t SOFDelta = (SOFCountIntSafe - SOFCountIntSafeOld) * 32u;

        //Report ID is 0x01 always for this example, based on the report descriptor.
        buffer[0] = 0x01;

        //	byte[1]: bit 0 = tip switch
        //	byte[1]: bit 1 = barrel switch
        //	byte[1]: bit 2 = eraser switch
        //	byte[1]: bit 3 = invert
        //	byte[1]: bit 4 = in-range (used for hover detection.  If actually indicating tip switch pressed, must set in-range = 1 as well)
        //	byte[1]: bits 5-7 = pad bits, unused
        buffer[1] = 0b00010000;		//See above individual bit definitions.
        buffer[2] = 0b00000000;		//bits 0-7 are all pad bits and are not used

        buffer[7] = 0x00;	//Byte 6 is LSB of tip pressure (0-32767)
        buffer[8] = 0x00;	//Byte 7 is MSB of tip pressure (0-32767)

        buffer[9] = 0x00;	//Byte 8 is x tilt LSB	(-32767 to 32767)
        buffer[10] = 0x00;	//Byte 9 is x tilt MSB	(-32767 to 32767)

        buffer[11] = 0x00;	//Byte 10 is y tilt LSB	(-32767 to 32767)
        buffer[12] = 0x00;	//Byte 11 is y tilt MSB	(-32767 to 32767)

        if(CoordinatesChanging == true)
        {
            buffer[1] = 0b00010001;	//Tip switch and in range indicators set.
            buffer[7] = 0xFF;	//Byte 6 is LSB of tip pressure (0-32767)
            buffer[8] = 0x7F;	//Byte 7 is MSB of tip pressure (0-32767)

            //Decide what type of data to send to host, based on number of times
            //the user pressed the button.
            switch(TimesPressed)
            {
                case 1:		//Just go to "home" coordinates
                    buffer[1] = 0x10;	//In range set, but tip switch not pressed.
                    buffer[7] = 0x00;	//Byte 6 is LSB of tip pressure (0-32767)
                    buffer[8] = 0x00;	//Byte 7 is MSB of tip pressure (0-32767)
                break;

                case 2:
                    //Sweep the X coordinate quickly to perform a "back" flick
                    //Make the cursor more more to the right of the screen (X plus)
                    XCoordinate = XCoordinate + SOFDelta;
                    if(XCoordinate > (X_COORD_HOME + 900u))
                    {
                        CoordinatesChanging = false;
                    }
                    break;

                case 3:
                    //Sweep the Y coordinate to perform a "drag up" flick
                    //Make the cursor move more to the top of the screen (Y minus)
                    YCoordinate = YCoordinate - ((SOFDelta << 2)/3);
                    if(YCoordinate & 0x8000)	//check for underflow
                        YCoordinate = 0x0000;
                    if(YCoordinate < (Y_COORD_HOME - 1200u))
                    {
                        CoordinatesChanging = false;
                    }
                break;

                case 4:
                    //Sweep the X coordinate to perform a "forward" flick
                    //Make the cursor more more to the left of the screen (X minus)
                    XCoordinate = XCoordinate - SOFDelta;
                    if(XCoordinate & 0x8000)	//check for underflow
                        XCoordinate = 0x0000;
                    if(XCoordinate < (X_COORD_HOME - 900u))
                    {
                        CoordinatesChanging = false;
                    }
                break;

                case 5:
                    //Sweep the Y coordinate to perform a "drag down" flick
                    //Make the cursor more more to the bottom of the screen (Y plus)
                    YCoordinate = YCoordinate + ((SOFDelta << 2)/3);
                    if(YCoordinate > (Y_COORD_HOME + 1200u))
                    {
                        CoordinatesChanging = false;
                    }
                    break;

                default:
                    break;
            } //end switch(TimesPressed)
        } //end if(CoordinatesChanging == true)

        buffer[3] = XCoordinate;		//Byte 2 is LSB of x coord (0-32767)
        buffer[4] = (XCoordinate >> 8);	//Byte 3 is MSB of x coord (0-32767)

        buffer[5] = YCoordinate;		//Byte 2 is LSB of y coord (0-32767)
        buffer[6] = (YCoordinate >> 8);	//Byte 3 is MSB of y coord (0-32767)


        //copy over the data to the HID buffer
        hid_report_in[0] = buffer[0];
        hid_report_in[1] = buffer[1];
        hid_report_in[2] = buffer[2];
        hid_report_in[3] = buffer[3];
        hid_report_in[4] = buffer[4];
        hid_report_in[5] = buffer[5];
        hid_report_in[6] = buffer[6];
        hid_report_in[7] = buffer[7];
        hid_report_in[8] = buffer[8];
        hid_report_in[9] = buffer[9];
        hid_report_in[10] = buffer[10];
        hid_report_in[11] = buffer[11];
        hid_report_in[12] = buffer[12];

        //Send the packet over USB to the host.  Make sure the handle wasn't
        //busy before calling the HIDTxPacket() function.
        lastTransmission = HIDTxPacket(HID_EP, (uint8_t*)hid_report_in, 13);

        //Counter used to keep track of how many packets have been sent, to decide what to do next
        ReportsSent++;
        if(ReportsSent == 60)
        {
            //but we still want to send a few more packets with the tip switch off, and no movement
            CoordinatesChanging = false;
        }
        if(ReportsSent == 80)
        {
            //We finished sending the flick + "idle".  No need to send more packets for now.
            FlickPending = false;
        }

        //Save the current value, so that we will know how much time has elapsed
        //when the Emulate_Digitizer() function gets called again.
        SOFCountIntSafeOld = SOFCountIntSafe;

    }//end if(HIDTxHandleBusy(lastTransmission) == 0)
    
}//end Emulate_Digitizer
