/*********************************************************************
 *
 *                   CHACHA20 Library Demo Project
 *
 *********************************************************************
 * FileName:        main.c
 * Dependencies:    None
 * Processor:       PIC24F
 * Company:         Microchip Technology, Inc.
 *
 * Software License Agreement
 *
 * Copyright (C) 2002-2014 Microchip Technology Inc.  All rights
 * reserved.
 *
 * Microchip licenses to you the right to use, modify, copy, and
 * distribute:
 * (i)  the Software when embedded on a Microchip microcontroller or
 *      digital signal controller product ("Device") which is
 *      integrated into Licensee's product; or
 * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
 *        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
 *        used in conjunction with a Microchip ethernet controller for
 *        the sole purpose of interfacing with the ethernet controller.
 *
 * You should refer to the license agreement accompanying this
 * Software for additional information regarding your rights and
 * obligations.
 *
 * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
 * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
 * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
 * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
 * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
 * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
 *
 * IMPORTANT:  The implementation and use of third party algorithms,
 * specifications and/or other technology may require a license from
 * various third parties.  It is your responsibility to obtain
 * information regarding any applicable licensing obligations.
 *
 ********************************************************************/

#include "crypto_sw/chacha20_sw.h"
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

// This file demonstrates the use of this library with a test vector from IETF's "ChaCha20Poly1305 for TLS" RFC draft
// http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-00#page-9

// An encryption context
CHACHA20_SW_CONTEXT context;

// A context for decryption
CHACHA20_SW_CONTEXT decryptContext;

// The keys to use
const uint8_t key0[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  \
                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,};
const uint8_t key1[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  \
                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,};
const uint8_t keyinc[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,  \
                    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,};

// The nonces to use
const uint8_t nonce0[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,};
const uint8_t nonce1[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,};
const uint8_t nonce1ls[] = {0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,};
const uint8_t nonceinc[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,};

// Buffer for input
// Since the result of the encryption primative is simply xor'd with the input to produce the output, there's
// no real reason to use actual input to verify functionality.  We can use all zeros instead
uint8_t input[512];

// Buffer for output
uint8_t output[512];

// Test vector results
const uint8_t result1[] = \
    {0x76,0xb8,0xe0,0xad,0xa0,0xf1,0x3d,0x90,0x40,0x5d,0x6a,0xe5,0x53,0x86,0xbd,0x28,\
        0xbd,0xd2,0x19,0xb8,0xa0,0x8d,0xed,0x1a,0xa8,0x36,0xef,0xcc,0x8b,0x77,0x0d,0xc7,\
        0xda,0x41,0x59,0x7c,0x51,0x57,0x48,0x8d,0x77,0x24,0xe0,0x3f,0xb8,0xd8,0x4a,0x37,\
        0x6a,0x43,0xb8,0xf4,0x15,0x18,0xa1,0x1c,0xc3,0x87,0xb6,0x69,};
const uint8_t result2[] = \
    {0x45,0x40,0xf0,0x5a,0x9f,0x1f,0xb2,0x96,0xd7,0x73,0x6e,0x7b,0x20,0x8e,0x3c,0x96,\
        0xeb,0x4f,0xe1,0x83,0x46,0x88,0xd2,0x60,0x4f,0x45,0x09,0x52,0xed,0x43,0x2d,0x41,\
        0xbb,0xe2,0xa0,0xb6,0xea,0x75,0x66,0xd2,0xa5,0xd1,0xe7,0xe2,0x0d,0x42,0xaf,0x2c,\
        0x53,0xd7,0x92,0xb1,0xc4,0x3f,0xea,0x81,0x7e,0x9a,0xd2,0x75,};
const uint8_t result3[] = \
    {0xde,0x9c,0xba,0x7b,0xf3,0xd6,0x9e,0xf5,0xe7,0x86,0xdc,0x63,0x97,0x3f,0x65,0x3a,\
        0x0b,0x49,0xe0,0x15,0xad,0xbf,0xf7,0x13,0x4f,0xcb,0x7d,0xf1,0x37,0x82,0x10,0x31,\
        0xe8,0x5a,0x05,0x02,0x78,0xa7,0x08,0x45,0x27,0x21,0x4f,0x73,0xef,0xc7,0xfa,0x5b,\
        0x52,0x77,0x06,0x2e,0xb7,0xa0,0x43,0x3e,0x44,0x5f,0x41,0xe3,};
const uint8_t result4[] = \
    {0xef,0x3f,0xdf,0xd6,0xc6,0x15,0x78,0xfb,0xf5,0xcf,0x35,0xbd,0x3d,0xd3,0x3b,0x80,\
        0x09,0x63,0x16,0x34,0xd2,0x1e,0x42,0xac,0x33,0x96,0x0b,0xd1,0x38,0xe5,0x0d,0x32,\
        0x11,0x1e,0x4c,0xaf,0x23,0x7e,0xe5,0x3c,0xa8,0xad,0x64,0x26,0x19,0x4a,0x88,0x54,\
        0x5d,0xdc,0x49,0x7a,0x0b,0x46,0x6e,0x7d,0x6b,0xbd,0xb0,0x04,};
const uint8_t result5[] = \
    {0xf7,0x98,0xa1,0x89,0xf1,0x95,0xe6,0x69,0x82,0x10,0x5f,0xfb,0x64,0x0b,0xb7,0x75,\
        0x7f,0x57,0x9d,0xa3,0x16,0x02,0xfc,0x93,0xec,0x01,0xac,0x56,0xf8,0x5a,0xc3,0xc1,\
        0x34,0xa4,0x54,0x7b,0x73,0x3b,0x46,0x41,0x30,0x42,0xc9,0x44,0x00,0x49,0x17,0x69,\
        0x05,0xd3,0xbe,0x59,0xea,0x1c,0x53,0xf1,0x59,0x16,0x15,0x5c,0x2b,0xe8,0x24,0x1a,\
        0x38,0x00,0x8b,0x9a,0x26,0xbc,0x35,0x94,0x1e,0x24,0x44,0x17,0x7c,0x8a,0xde,0x66,\
        0x89,0xde,0x95,0x26,0x49,0x86,0xd9,0x58,0x89,0xfb,0x60,0xe8,0x46,0x29,0xc9,0xbd,\
        0x9a,0x5a,0xcb,0x1c,0xc1,0x18,0xbe,0x56,0x3e,0xb9,0xb3,0xa4,0xa4,0x72,0xf8,0x2e,\
        0x09,0xa7,0xe7,0x78,0x49,0x2b,0x56,0x2e,0xf7,0x13,0x0e,0x88,0xdf,0xe0,0x31,0xc7,\
        0x9d,0xb9,0xd4,0xf7,0xc7,0xa8,0x99,0x15,0x1b,0x9a,0x47,0x50,0x32,0xb6,0x3f,0xc3,\
        0x85,0x24,0x5f,0xe0,0x54,0xe3,0xdd,0x5a,0x97,0xa5,0xf5,0x76,0xfe,0x06,0x40,0x25,\
        0xd3,0xce,0x04,0x2c,0x56,0x6a,0xb2,0xc5,0x07,0xb1,0x38,0xdb,0x85,0x3e,0x3d,0x69,\
        0x59,0x66,0x09,0x96,0x54,0x6c,0xc9,0xc4,0xa6,0xea,0xfd,0xc7,0x77,0xc0,0x40,0xd7,\
        0x0e,0xaf,0x46,0xf7,0x6d,0xad,0x39,0x79,0xe5,0xc5,0x36,0x0c,0x33,0x17,0x16,0x6a,\
        0x1c,0x89,0x4c,0x94,0xa3,0x71,0x87,0x6a,0x94,0xdf,0x76,0x28,0xfe,0x4e,0xaa,0xf2,\
        0xcc,0xb2,0x7d,0x5a,0xaa,0xe0,0xad,0x7a,0xd0,0xf9,0xd4,0xb6,0xad,0x3b,0x54,0x09,\
        0x87,0x46,0xd4,0x52,0x4d,0x38,0x40,0x7a,0x6d,0xeb,};


int main (void)
{
    // Set the input buffer to zero
    memset (input, 0x00, 512);

    // Test vector 1

    // Expand the key
    CHACHA20_SW_KeyExpand(&context, (uint8_t *)nonce0, (uint8_t *)key0, 32);

    // Perform a 60-byte encryption
    CHACHA20_SW_Encrypt (&context, output, input, 60);

    // Check the result
    if (memcmp (output, result1, 60) != 0)
    {
        while(1);
    }

    // Verify that this data can be decrypted
    CHACHA20_SW_KeyExpand(&decryptContext, (uint8_t *)nonce0, (uint8_t *)key0, 32);
    // Decrypt in place
    CHACHA20_SW_Decrypt (&decryptContext, output, output, 60);
    // Compare to the input array
    if (memcmp (output, input, 60) != 0)
    {
        while(1);
    }

    // Test vector 2

    // Expand the key
    CHACHA20_SW_KeyExpand(&context, (uint8_t *)nonce0, (uint8_t *)key1, 32);

    // Perform a 60-byte encryption
    CHACHA20_SW_Encrypt (&context, output, input, 60);

    // Check the result
    if (memcmp (output, result2, 60) != 0)
    {
        while(1);
    }

    // Test vector 3

    // Expand the key
    CHACHA20_SW_KeyExpand(&context, (uint8_t *)nonce1, (uint8_t *)key0, 32);

    // Perform a 60-byte encryption
    CHACHA20_SW_Encrypt (&context, output, input, 60);

    // Check the result
    if (memcmp (output, result3, 60) != 0)
    {
        while(1);
    }

    // Test vector 4

    // Expand the key
    CHACHA20_SW_KeyExpand(&context, (uint8_t *)nonce1ls, (uint8_t *)key0, 32);

    // Perform a 60-byte encryption
    CHACHA20_SW_Encrypt (&context, output, input, 60);

    // Check the result
    if (memcmp (output, result4, 60) != 0)
    {
        while(1);
    }

    // Test vector 5

    // Expand the key
    CHACHA20_SW_KeyExpand(&context, (uint8_t *)nonceinc, (uint8_t *)keyinc, 32);

    // Perform a 250-byte encryption
    CHACHA20_SW_Encrypt (&context, output, input, 250);

    // Check the result
    if (memcmp (output, result5, 250) != 0)
    {
        while(1);
    }
    
    // Test for PositionSet(), uses test vector 5.
    
    // Clear old results
    memset(output, 0x00, sizeof(output));
    
    // Expand the key
    CHACHA20_SW_KeyExpand(&context, (uint8_t *)nonceinc, (uint8_t *)keyinc, 32);

    // Set the current position to byte 100.
    CHACHA20_SW_PositionSet(&context, 0, 0, 100);
    
    // Perform a 150-byte encryption at offset 100
    CHACHA20_SW_Encrypt (&context, &output[100], &input[100], 150);

    // Set the current position to byte 0.
    CHACHA20_SW_PositionSet(&context, 0, 0, 0);
    
    // Perform a 100-byte encryption at offset 0
    CHACHA20_SW_Encrypt (&context, &output[0], &input[0], 150);
    
    // Check the result
    if (memcmp (output, result5, 250) != 0)
    {
        while(1);
    }

    while(1);
}




