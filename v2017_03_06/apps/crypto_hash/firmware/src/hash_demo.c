/*********************************************************************
 *
 *    Hash Demo
 *
 *********************************************************************
 * FileName:        hash_demo.c
 * Dependencies:    None
 * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
 * Company:         Microchip Technology, Inc.
 *
 * Software License Agreement
 *
 * Copyright (C) 2002-2012 Microchip Technology Inc.  All rights
 * reserved.
 *
 * Microchip licenses to you the right to use, modify, copy, and
 * distribute:
 * (i)  the Software when embedded on a Microchip microcontroller or
 *      digital signal controller product ("Device") which is
 *      integrated into Licensee's product; or
 * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
 *        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
 *        used in conjunction with a Microchip ethernet controller for
 *        the sole purpose of interfacing with the ethernet controller.
 *
 * You should refer to the license agreement accompanying this
 * Software for additional information regarding your rights and
 * obligations.
 *
 * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
 * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
 * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
 * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
 * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
 * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
 *
 * IMPORTANT:  The implementation and use of third party algorithms,
 * specifications and/or other technology may require a license from
 * various third parties.  It is your responsibility to obtain
 * information regarding any applicable licensing obligations.
 *
 ********************************************************************/

#include "crypto_hash/crypto_hash.h"
#include <stdint.h>
#include <string.h>

// Hash contexts
union
{
    MD5_CONTEXT contextMd5;             // Context for MD5
    SHA1_CONTEXT context1;              // Context for SHA-1
    SHA256_CONTEXT context256;          // Context for SHA-224/256
    SHA512_CONTEXT context512;          // Context for SHA-384/512
} contexts;

// Working buffers for SHA hashes
union
{
    uint64_t workingBuffer64[80];       // Working buffer for SHA-384/512
    uint32_t workingBuffer32[80];       // Working buffer for SHA-1/224/256
}workingBuffer;;

// Sample message texts
const uint8_t message0[] = "";
const uint8_t message1[] = "a";
const uint8_t message2[] = "abc";
const uint8_t message3[] = "message digest";
const uint8_t message4[] = "abcdefghijklmnopqrstuvwxyz";
const uint8_t message5[] = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
const uint8_t message6[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
const uint8_t message7[] = "1234567890";
const uint8_t message8[] = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";

// Message digests for MD5 (for comparison)
const uint8_t message0_md5_digest[] = {0xd4,0x1d,0x8c,0xd9,0x8f,0x00,0xb2,0x04,0xe9,0x80,0x09,0x98,0xec,0xf8,0x42,0x7e,};
const uint8_t message1_md5_digest[] = {0x0c,0xc1,0x75,0xb9,0xc0,0xf1,0xb6,0xa8,0x31,0xc3,0x99,0xe2,0x69,0x77,0x26,0x61,};
const uint8_t message2_md5_digest[] = {0x90,0x01,0x50,0x98,0x3c,0xd2,0x4f,0xb0,0xd6,0x96,0x3f,0x7d,0x28,0xe1,0x7f,0x72,};
const uint8_t message3_md5_digest[] = {0xf9,0x6b,0x69,0x7d,0x7c,0xb7,0x93,0x8d,0x52,0x5a,0x2f,0x31,0xaa,0xf1,0x61,0xd0,};
const uint8_t message4_md5_digest[] = {0xc3,0xfc,0xd3,0xd7,0x61,0x92,0xe4,0x00,0x7d,0xfb,0x49,0x6c,0xca,0x67,0xe1,0x3b,};

// Message digests for SHA-1 (for comparison)
const uint8_t message0_1_digest[] = {0xDA,0x39,0xA3,0xEE,0x5E,0x6B,0x4B,0x0D,0x32,0x55,0xBF,0xEF,0x95,0x60,0x18,0x90,0xAF,0xD8,0x07,0x09,};
const uint8_t message1_1_digest[] = {0x86,0xF7,0xE4,0x37,0xFA,0xA5,0xA7,0xFC,0xE1,0x5D,0x1D,0xDC,0xB9,0xEA,0xEA,0xEA,0x37,0x76,0x67,0xB8,};
const uint8_t message2_1_digest[] = {0xA9,0x99,0x3E,0x36,0x47,0x06,0x81,0x6A,0xBA,0x3E,0x25,0x71,0x78,0x50,0xC2,0x6C,0x9C,0xD0,0xD8,0x9D,};
const uint8_t message3_1_digest[] = {0xC1,0x22,0x52,0xCE,0xDA,0x8B,0xE8,0x99,0x4D,0x5F,0xA0,0x29,0x0A,0x47,0x23,0x1C,0x1D,0x16,0xAA,0xE3,};
const uint8_t message4_1_digest[] = {0x32,0xD1,0x0C,0x7B,0x8C,0xF9,0x65,0x70,0xCA,0x04,0xCE,0x37,0xF2,0xA1,0x9D,0x84,0x24,0x0D,0x3A,0x89,};
const uint8_t message5_1_digest[] = {0x84,0x98,0x3E,0x44,0x1C,0x3B,0xD2,0x6E,0xBA,0xAE,0x4A,0xA1,0xF9,0x51,0x29,0xE5,0xE5,0x46,0x70,0xF1,};
const uint8_t message6_1_digest[] = {0x76,0x1C,0x45,0x7B,0xF7,0x3B,0x14,0xD2,0x7E,0x9E,0x92,0x65,0xC4,0x6F,0x4B,0x4D,0xDA,0x11,0xF9,0x40,};
const uint8_t message7_1_digest[] = {0x50,0xAB,0xF5,0x70,0x6A,0x15,0x09,0x90,0xA0,0x8B,0x2C,0x5E,0xA4,0x0F,0xA0,0xE5,0x85,0x55,0x47,0x32,};
const uint8_t message8_1_digest[] = {0x34,0xAA,0x97,0x3C,0xD4,0xC4,0xDA,0xA4,0xF6,0x1E,0xEB,0x2B,0xDB,0xAD,0x27,0x31,0x65,0x34,0x01,0x6F,};

// Message digests for SHA-224 (for comparison)
const uint8_t message2_224_digest[] = {0x23,0x09,0x7D,0x22,0x34,0x05,0xD8,0x22,0x86,0x42,0xA4,0x77,0xBD,0xA2,0x55,0xB3,0x2A,0xAD,0xBC,0xE4,0xBD,0xA0,0xB3,0xF7,0xE3,0x6C,0x9D,0xA7,};
const uint8_t message5_224_digest[] = {0x75,0x38,0x8B,0x16,0x51,0x27,0x76,0xCC,0x5D,0xBA,0x5D,0xA1,0xFD,0x89,0x01,0x50,0xB0,0xC6,0x45,0x5C,0xB4,0xF5,0x8B,0x19,0x52,0x52,0x25,0x25,};

// Message digests for SHA-256 (for comparison)
const uint8_t message0_256_digest[] = {0xE3,0xB0,0xC4,0x42,0x98,0xFC,0x1C,0x14,0x9A,0xFB,0xF4,0xC8,0x99,0x6F,0xB9,0x24,0x27,0xAE,0x41,0xE4,0x64,0x9B,0x93,0x4C,0xA4,0x95,0x99,0x1B,0x78,0x52,0xB8,0x55,};
const uint8_t message1_256_digest[] = {0xCA,0x97,0x81,0x12,0xCA,0x1B,0xBD,0xCA,0xFA,0xC2,0x31,0xB3,0x9A,0x23,0xDC,0x4D,0xA7,0x86,0xEF,0xF8,0x14,0x7C,0x4E,0x72,0xB9,0x80,0x77,0x85,0xAF,0xEE,0x48,0xBB,};
const uint8_t message2_256_digest[] = {0xBA,0x78,0x16,0xBF,0x8F,0x01,0xCF,0xEA,0x41,0x41,0x40,0xDE,0x5D,0xAE,0x22,0x23,0xB0,0x03,0x61,0xA3,0x96,0x17,0x7A,0x9C,0xB4,0x10,0xFF,0x61,0xF2,0x00,0x15,0xAD,};
const uint8_t message3_256_digest[] = {0xF7,0x84,0x6F,0x55,0xCF,0x23,0xE1,0x4E,0xEB,0xEA,0xB5,0xB4,0xE1,0x55,0x0C,0xAD,0x5B,0x50,0x9E,0x33,0x48,0xFB,0xC4,0xEF,0xA3,0xA1,0x41,0x3D,0x39,0x3C,0xB6,0x50,};
const uint8_t message4_256_digest[] = {0x71,0xC4,0x80,0xDF,0x93,0xD6,0xAE,0x2F,0x1E,0xFA,0xD1,0x44,0x7C,0x66,0xC9,0x52,0x5E,0x31,0x62,0x18,0xCF,0x51,0xFC,0x8D,0x9E,0xD8,0x32,0xF2,0xDA,0xF1,0x8B,0x73,};
const uint8_t message5_256_digest[] = {0x24,0x8D,0x6A,0x61,0xD2,0x06,0x38,0xB8,0xE5,0xC0,0x26,0x93,0x0C,0x3E,0x60,0x39,0xA3,0x3C,0xE4,0x59,0x64,0xFF,0x21,0x67,0xF6,0xEC,0xED,0xD4,0x19,0xDB,0x06,0xC1,};
const uint8_t message6_256_digest[] = {0xDB,0x4B,0xFC,0xBD,0x4D,0xA0,0xCD,0x85,0xA6,0x0C,0x3C,0x37,0xD3,0xFB,0xD8,0x80,0x5C,0x77,0xF1,0x5F,0xC6,0xB1,0xFD,0xFE,0x61,0x4E,0xE0,0xA7,0xC8,0xFD,0xB4,0xC0,};
const uint8_t message7_256_digest[] = {0xF3,0x71,0xBC,0x4A,0x31,0x1F,0x2B,0x00,0x9E,0xEF,0x95,0x2D,0xD8,0x3C,0xA8,0x0E,0x2B,0x60,0x02,0x6C,0x8E,0x93,0x55,0x92,0xD0,0xF9,0xC3,0x08,0x45,0x3C,0x81,0x3E,};
const uint8_t message8_256_digest[] = {0xCD,0xC7,0x6E,0x5C,0x99,0x14,0xFB,0x92,0x81,0xA1,0xC7,0xE2,0x84,0xD7,0x3E,0x67,0xF1,0x80,0x9A,0x48,0xA4,0x97,0x20,0x0E,0x04,0x6D,0x39,0xCC,0xC7,0x11,0x2C,0xD0,};

// Message digests for SHA-384 (for comparison)
const uint8_t message0_384_digest[] = {0x38,0xB0,0x60,0xA7,0x51,0xAC,0x96,0x38,0x4C,0xD9,0x32,0x7E,0xB1,0xB1,0xE3,0x6A,0x21,0xFD,0xB7,0x11,0x14,0xBE,0x07,0x43,0x4C,0x0C,0xC7,0xBF,0x63,0xF6,0xE1,0xDA,0x27,0x4E,0xDE,0xBF,0xE7,0x6F,0x65,0xFB,0xD5,0x1A,0xD2,0xF1,0x48,0x98,0xB9,0x5B,};
const uint8_t message1_384_digest[] = {0x54,0xA5,0x9B,0x9F,0x22,0xB0,0xB8,0x08,0x80,0xD8,0x42,0x7E,0x54,0x8B,0x7C,0x23,0xAB,0xD8,0x73,0x48,0x6E,0x1F,0x03,0x5D,0xCE,0x9C,0xD6,0x97,0xE8,0x51,0x75,0x03,0x3C,0xAA,0x88,0xE6,0xD5,0x7B,0xC3,0x5E,0xFA,0xE0,0xB5,0xAF,0xD3,0x14,0x5F,0x31,};
const uint8_t message2_384_digest[] = {0xCB,0x00,0x75,0x3F,0x45,0xA3,0x5E,0x8B,0xB5,0xA0,0x3D,0x69,0x9A,0xC6,0x50,0x07,0x27,0x2C,0x32,0xAB,0x0E,0xDE,0xD1,0x63,0x1A,0x8B,0x60,0x5A,0x43,0xFF,0x5B,0xED,0x80,0x86,0x07,0x2B,0xA1,0xE7,0xCC,0x23,0x58,0xBA,0xEC,0xA1,0x34,0xC8,0x25,0xA7,};
const uint8_t message3_384_digest[] = {0x47,0x3E,0xD3,0x51,0x67,0xEC,0x1F,0x5D,0x8E,0x55,0x03,0x68,0xA3,0xDB,0x39,0xBE,0x54,0x63,0x9F,0x82,0x88,0x68,0xE9,0x45,0x4C,0x23,0x9F,0xC8,0xB5,0x2E,0x3C,0x61,0xDB,0xD0,0xD8,0xB4,0xDE,0x13,0x90,0xC2,0x56,0xDC,0xBB,0x5D,0x5F,0xD9,0x9C,0xD5,};
const uint8_t message4_384_digest[] = {0xFE,0xB6,0x73,0x49,0xDF,0x3D,0xB6,0xF5,0x92,0x48,0x15,0xD6,0xC3,0xDC,0x13,0x3F,0x09,0x18,0x09,0x21,0x37,0x31,0xFE,0x5C,0x7B,0x5F,0x49,0x99,0xE4,0x63,0x47,0x9F,0xF2,0x87,0x7F,0x5F,0x29,0x36,0xFA,0x63,0xBB,0x43,0x78,0x4B,0x12,0xF3,0xEB,0xB4,};
const uint8_t message5_384_digest[] = {0x33,0x91,0xFD,0xDD,0xFC,0x8D,0xC7,0x39,0x37,0x07,0xA6,0x5B,0x1B,0x47,0x09,0x39,0x7C,0xF8,0xB1,0xD1,0x62,0xAF,0x05,0xAB,0xFE,0x8F,0x45,0x0D,0xE5,0xF3,0x6B,0xC6,0xB0,0x45,0x5A,0x85,0x20,0xBC,0x4E,0x6F,0x5F,0xE9,0x5B,0x1F,0xE3,0xC8,0x45,0x2B,};
const uint8_t message6_384_digest[] = {0x17,0x61,0x33,0x6E,0x3F,0x7C,0xBF,0xE5,0x1D,0xEB,0x13,0x7F,0x02,0x6F,0x89,0xE0,0x1A,0x44,0x8E,0x3B,0x1F,0xAF,0xA6,0x40,0x39,0xC1,0x46,0x4E,0xE8,0x73,0x2F,0x11,0xA5,0x34,0x1A,0x6F,0x41,0xE0,0xC2,0x02,0x29,0x47,0x36,0xED,0x64,0xDB,0x1A,0x84,};
const uint8_t message7_384_digest[] = {0xB1,0x29,0x32,0xB0,0x62,0x7D,0x1C,0x06,0x09,0x42,0xF5,0x44,0x77,0x64,0x15,0x56,0x55,0xBD,0x4D,0xA0,0xC9,0xAF,0xA6,0xDD,0x9B,0x9E,0xF5,0x31,0x29,0xAF,0x1B,0x8F,0xB0,0x19,0x59,0x96,0xD2,0xDE,0x9C,0xA0,0xDF,0x9D,0x82,0x1F,0xFE,0xE6,0x70,0x26,};
const uint8_t message8_384_digest[] = {0x9D,0x0E,0x18,0x09,0x71,0x64,0x74,0xCB,0x08,0x6E,0x83,0x4E,0x31,0x0A,0x4A,0x1C,0xED,0x14,0x9E,0x9C,0x00,0xF2,0x48,0x52,0x79,0x72,0xCE,0xC5,0x70,0x4C,0x2A,0x5B,0x07,0xB8,0xB3,0xDC,0x38,0xEC,0xC4,0xEB,0xAE,0x97,0xDD,0xD8,0x7F,0x3D,0x89,0x85,};

// Message digests for SHA-512 (for comparison)
const uint8_t message0_512_digest[] = {0xCF,0x83,0xE1,0x35,0x7E,0xEF,0xB8,0xBD,0xF1,0x54,0x28,0x50,0xD6,0x6D,0x80,0x07,0xD6,0x20,0xE4,0x05,0x0B,0x57,0x15,0xDC,0x83,0xF4,0xA9,0x21,0xD3,0x6C,0xE9,0xCE,0x47,0xD0,0xD1,0x3C,0x5D,0x85,0xF2,0xB0,0xFF,0x83,0x18,0xD2,0x87,0x7E,0xEC,0x2F,0x63,0xB9,0x31,0xBD,0x47,0x41,0x7A,0x81,0xA5,0x38,0x32,0x7A,0xF9,0x27,0xDA,0x3E,};
const uint8_t message1_512_digest[] = {0x1F,0x40,0xFC,0x92,0xDA,0x24,0x16,0x94,0x75,0x09,0x79,0xEE,0x6C,0xF5,0x82,0xF2,0xD5,0xD7,0xD2,0x8E,0x18,0x33,0x5D,0xE0,0x5A,0xBC,0x54,0xD0,0x56,0x0E,0x0F,0x53,0x02,0x86,0x0C,0x65,0x2B,0xF0,0x8D,0x56,0x02,0x52,0xAA,0x5E,0x74,0x21,0x05,0x46,0xF3,0x69,0xFB,0xBB,0xCE,0x8C,0x12,0xCF,0xC7,0x95,0x7B,0x26,0x52,0xFE,0x9A,0x75,};
const uint8_t message2_512_digest[] = {0xDD,0xAF,0x35,0xA1,0x93,0x61,0x7A,0xBA,0xCC,0x41,0x73,0x49,0xAE,0x20,0x41,0x31,0x12,0xE6,0xFA,0x4E,0x89,0xA9,0x7E,0xA2,0x0A,0x9E,0xEE,0xE6,0x4B,0x55,0xD3,0x9A,0x21,0x92,0x99,0x2A,0x27,0x4F,0xC1,0xA8,0x36,0xBA,0x3C,0x23,0xA3,0xFE,0xEB,0xBD,0x45,0x4D,0x44,0x23,0x64,0x3C,0xE8,0x0E,0x2A,0x9A,0xC9,0x4F,0xA5,0x4C,0xA4,0x9F,};
const uint8_t message3_512_digest[] = {0x10,0x7D,0xBF,0x38,0x9D,0x9E,0x9F,0x71,0xA3,0xA9,0x5F,0x6C,0x05,0x5B,0x92,0x51,0xBC,0x52,0x68,0xC2,0xBE,0x16,0xD6,0xC1,0x34,0x92,0xEA,0x45,0xB0,0x19,0x9F,0x33,0x09,0xE1,0x64,0x55,0xAB,0x1E,0x96,0x11,0x8E,0x8A,0x90,0x5D,0x55,0x97,0xB7,0x20,0x38,0xDD,0xB3,0x72,0xA8,0x98,0x26,0x04,0x6D,0xE6,0x66,0x87,0xBB,0x42,0x0E,0x7C,};
const uint8_t message4_512_digest[] = {0x4D,0xBF,0xF8,0x6C,0xC2,0xCA,0x1B,0xAE,0x1E,0x16,0x46,0x8A,0x05,0xCB,0x98,0x81,0xC9,0x7F,0x17,0x53,0xBC,0xE3,0x61,0x90,0x34,0x89,0x8F,0xAA,0x1A,0xAB,0xE4,0x29,0x95,0x5A,0x1B,0xF8,0xEC,0x48,0x3D,0x74,0x21,0xFE,0x3C,0x16,0x46,0x61,0x3A,0x59,0xED,0x54,0x41,0xFB,0x0F,0x32,0x13,0x89,0xF7,0x7F,0x48,0xA8,0x79,0xC7,0xB1,0xF1,};
const uint8_t message5_512_digest[] = {0x20,0x4A,0x8F,0xC6,0xDD,0xA8,0x2F,0x0A,0x0C,0xED,0x7B,0xEB,0x8E,0x08,0xA4,0x16,0x57,0xC1,0x6E,0xF4,0x68,0xB2,0x28,0xA8,0x27,0x9B,0xE3,0x31,0xA7,0x03,0xC3,0x35,0x96,0xFD,0x15,0xC1,0x3B,0x1B,0x07,0xF9,0xAA,0x1D,0x3B,0xEA,0x57,0x78,0x9C,0xA0,0x31,0xAD,0x85,0xC7,0xA7,0x1D,0xD7,0x03,0x54,0xEC,0x63,0x12,0x38,0xCA,0x34,0x45,};
const uint8_t message6_512_digest[] = {0x1E,0x07,0xBE,0x23,0xC2,0x6A,0x86,0xEA,0x37,0xEA,0x81,0x0C,0x8E,0xC7,0x80,0x93,0x52,0x51,0x5A,0x97,0x0E,0x92,0x53,0xC2,0x6F,0x53,0x6C,0xFC,0x7A,0x99,0x96,0xC4,0x5C,0x83,0x70,0x58,0x3E,0x0A,0x78,0xFA,0x4A,0x90,0x04,0x1D,0x71,0xA4,0xCE,0xAB,0x74,0x23,0xF1,0x9C,0x71,0xB9,0xD5,0xA3,0xE0,0x12,0x49,0xF0,0xBE,0xBD,0x58,0x94,};
const uint8_t message7_512_digest[] = {0x72,0xEC,0x1E,0xF1,0x12,0x4A,0x45,0xB0,0x47,0xE8,0xB7,0xC7,0x5A,0x93,0x21,0x95,0x13,0x5B,0xB6,0x1D,0xE2,0x4E,0xC0,0xD1,0x91,0x40,0x42,0x24,0x6E,0x0A,0xEC,0x3A,0x23,0x54,0xE0,0x93,0xD7,0x6F,0x30,0x48,0xB4,0x56,0x76,0x43,0x46,0x90,0x0C,0xB1,0x30,0xD2,0xA4,0xFD,0x5D,0xD1,0x6A,0xBB,0x5E,0x30,0xBC,0xB8,0x50,0xDE,0xE8,0x43,};
const uint8_t message8_512_digest[] = {0xE7,0x18,0x48,0x3D,0x0C,0xE7,0x69,0x64,0x4E,0x2E,0x42,0xC7,0xBC,0x15,0xB4,0x63,0x8E,0x1F,0x98,0xB1,0x3B,0x20,0x44,0x28,0x56,0x32,0xA8,0x03,0xAF,0xA9,0x73,0xEB,0xDE,0x0F,0xF2,0x44,0x87,0x7E,0xA6,0x0A,0x4C,0xB0,0x43,0x2C,0xE5,0x77,0xC3,0x1B,0xEB,0x00,0x9C,0x5C,0x2C,0x49,0xAA,0x2E,0x4E,0xAD,0xB2,0x17,0xAD,0x8C,0xC0,0x9B,};

// Digest buffer for returned hashes
uint8_t digest[64];

// DEMO_LONG_TEST will enable hashing of message 8 - the 'a' character, repeated 1 million times.
//#define DEMO_LONG_TEST

int main (void)
{
    uint32_t counter;

    //****************************************************************
    // MD5 Demo
    //****************************************************************
    MD5_Initialize (&contexts.contextMd5);
    MD5_DataAdd (&contexts.contextMd5, (uint8_t *)message0, 0);
    MD5_Calculate (&contexts.contextMd5, digest);
    if (memcmp(digest, message0_md5_digest, 16))
        return 1;

    MD5_Initialize (&contexts.contextMd5);
    MD5_DataAdd (&contexts.contextMd5, (uint8_t *)message1, 1);
    MD5_Calculate (&contexts.contextMd5, digest);
    if (memcmp(digest, message1_md5_digest, 16))
        return 1;

    MD5_Initialize (&contexts.contextMd5);
    MD5_DataAdd (&contexts.contextMd5, (uint8_t *)message2, 3);
    MD5_Calculate (&contexts.contextMd5, digest);
    if (memcmp(digest, message2_md5_digest, 16))
        return 1;

    MD5_Initialize (&contexts.contextMd5);
    MD5_DataAdd (&contexts.contextMd5, (uint8_t *)message3, 14);
    MD5_Calculate (&contexts.contextMd5, digest);
    if (memcmp(digest, message3_md5_digest, 16))
        return 1;

    MD5_Initialize (&contexts.contextMd5);
    MD5_DataAdd (&contexts.contextMd5, (uint8_t *)message4, 26);
    MD5_Calculate (&contexts.contextMd5, digest);
    if (memcmp(digest, message4_md5_digest, 16))
        return 1;


    //****************************************************************
    // SHA-1 Demo
    //****************************************************************
    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    SHA1_DataAdd (&contexts.context1, (uint8_t *)message0, 0);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message0_1_digest, 20))
        return 1;

    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    SHA1_DataAdd (&contexts.context1, (uint8_t *)message1, 1);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message1_1_digest, 20))
        return 1;

    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    SHA1_DataAdd (&contexts.context1, (uint8_t *)message2, 3);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message2_1_digest, 20))
        return 1;

    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    SHA1_DataAdd (&contexts.context1, (uint8_t *)message3, 14);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message3_1_digest, 20))
        return 1;

    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    SHA1_DataAdd (&contexts.context1, (uint8_t *)message4, 26);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message4_1_digest, 20))
        return 1;

    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    SHA1_DataAdd (&contexts.context1, (uint8_t *)message5, 56);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message5_1_digest, 20))
        return 1;

    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    SHA1_DataAdd (&contexts.context1, (uint8_t *)message6, 62);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message6_1_digest, 20))
        return 1;

    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    for (counter = 0; counter < 8; counter++)
        SHA1_DataAdd (&contexts.context1, (uint8_t *)message7, 10);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message7_1_digest, 20))
        return 1;

#if defined (DEMO_LONG_TEST)
    SHA1_Initialize (&contexts.context1, workingBuffer.workingBuffer32);
    for (counter = 0; counter < 10000; counter++)
        SHA1_DataAdd (&contexts.context1, (uint8_t *)message8, 100);
    SHA1_Calculate (&contexts.context1, digest);
    if (memcmp(digest, message8_1_digest, 20))
        return 1;
#endif

    //****************************************************************
    // SHA-224 Demo
    //****************************************************************
    SHA256_Initialize (&contexts.context256, SHA2_224, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message2, 3);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message2_224_digest, 28))
        return 1;

    SHA256_Initialize (&contexts.context256, SHA2_224, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message5, 56);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message5_224_digest, 28))
        return 1;


    //****************************************************************
    // SHA-256 Demo
    //****************************************************************

    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message0, 0);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message0_256_digest, 32))
        return 1;

    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message1, 1);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message1_256_digest, 32))
        return 1;

    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message2, 3);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message2_256_digest, 32))
        return 1;

    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message3, 14);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message3_256_digest, 32))
        return 1;

    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message4, 26);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message4_256_digest, 32))
        return 1;

    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message5, 56);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message5_256_digest, 32))
        return 1;

    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    SHA256_DataAdd (&contexts.context256, (uint8_t *)message6, 62);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message6_256_digest, 32))
        return 1;

    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    for (counter = 0; counter < 8; counter++)
        SHA256_DataAdd (&contexts.context256, (uint8_t *)message7, 10);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message7_256_digest, 32))
        return 1;

#if defined (DEMO_LONG_TEST)
    SHA256_Initialize (&contexts.context256, SHA2_256, workingBuffer.workingBuffer32);
    for (counter = 0; counter < 10000; counter++)
        SHA256_DataAdd (&contexts.context256, (uint8_t *)message8, 100);
    SHA256_Calculate (&contexts.context256, digest);
    if (memcmp(digest, message8_256_digest, 32))
        return 1;
#endif

    //****************************************************************
    // SHA-384 Demo
    //****************************************************************
    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message0, 0);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message0_384_digest, 48))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message1, 1);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message1_384_digest, 48))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message2, 3);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message2_384_digest, 48))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message3, 14);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message3_384_digest, 48))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message4, 26);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message4_384_digest, 48))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message5, 56);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message5_384_digest, 48))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message6, 62);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message6_384_digest, 48))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    for (counter = 0; counter < 8; counter++)
        SHA512_DataAdd (&contexts.context512, (uint8_t *)message7, 10);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message7_384_digest, 48))
        return 1;

#if defined (DEMO_LONG_TEST)
    SHA512_Initialize (&contexts.context512, SHA2_384, workingBuffer.workingBuffer64);
    for (counter = 0; counter < 10000; counter++)
        SHA512_DataAdd (&contexts.context512, (uint8_t *)message8, 100);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message8_384_digest, 48))
        return 1;
#endif

    //****************************************************************
    // SHA-512 Demo
    //****************************************************************
    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message0, 0);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message0_512_digest, 64))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message1, 1);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message1_512_digest, 64))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message2, 3);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message2_512_digest, 64))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message3, 14);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message3_512_digest, 64))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message4, 26);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message4_512_digest, 64))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message5, 56);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message5_512_digest, 64))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    SHA512_DataAdd (&contexts.context512, (uint8_t *)message6, 62);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message6_512_digest, 64))
        return 1;

    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    for (counter = 0; counter < 8; counter++)
        SHA512_DataAdd (&contexts.context512, (uint8_t *)message7, 10);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message7_512_digest, 64))
        return 1;

#if defined (DEMO_LONG_TEST)
    SHA512_Initialize (&contexts.context512, SHA2_512, workingBuffer.workingBuffer64);
    for (counter = 0; counter < 10000; counter++)
        SHA512_DataAdd (&contexts.context512, (uint8_t *)message8, 100);
    SHA512_Calculate (&contexts.context512, digest);
    if (memcmp(digest, message8_512_digest, 64))
        return 1;
#endif


    return 0;
}







